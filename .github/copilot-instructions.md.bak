# Async NoStd Project - AI Agent Instructions

## Project Overview
**Workspace-based** freestanding Rust binary (`#![no_std]`, `#![no_main]`) with async/await via bare-metal Linux syscalls on x86_64. **Edition 2024** with workspace crate architecture (906 LOC, 15KB stripped binary).

## Architecture - Workspace Structure

```
Cargo.toml                  → Workspace root + binary target
src/main.rs (157 lines)     → Demo application (minimal, uses subcrates)
crates/
  ├─ syscall/ (209 lines)   → Generic syscall wrappers (syscall1-6 pattern)
  ├─ runtime/ (328 lines)   → Entry point, allocator, task scheduler, IO registry
  ├─ executor/ (59 lines)   → Worker-based task executor
  └─ net/ (153 lines)       → Network futures (Accept/Connect/Send/Recv)
```

**Dependency Graph**: `syscall` → `runtime` → `executor`/`net` → `main`

**Critical Rule**: Main binary has NO unsafe code. Subcrates encapsulate all unsafe operations with safe public APIs.

### Crate Responsibilities

**async-syscall** (`crates/syscall/lib.rs`)
- Generic syscall helpers: `syscall1()` through `syscall6()` with inline asm
- Safe wrappers: `write()`, `exit()`, `mmap()`, `socket()`, `bind()`, `listen()`, etc.
- `spawn_thread()`: Clone-based (CLONE_VM|FS|FILES|SIGHAND|SIGCHLD, NOT CLONE_THREAD)
- No dependencies, pure syscall layer

**async-runtime** (`crates/runtime/lib.rs`)
- `_start()`: Naked entry point with 16-byte stack alignment, calls `main_trampoline()`
- Bump allocator: 16MB mmap-backed heap, no deallocation (permanent allocations)
- Task scheduler: Lock-free Treiber stack for ready tasks, handle-based waker system
- IO registry: `spin::Mutex<Vec<IoEntry>>` for fd → waker mappings, `ppoll()`-based readiness
- Utilities: `read_ptr_array()`, `parse_cstring_usize()` for argv parsing
- **Depends on**: `async-syscall`, `spin`

**async-executor** (`crates/executor/lib.rs`)
- `Executor::enqueue_task()`: Registers task via `runtime::register_task()`
- `Executor::start_workers()`: Spawns worker threads (64KB stack each)
- `worker_trampoline()`: Polls scheduled tasks, calls `runtime::ppoll_and_schedule()` when idle
- `TASKS_REMAINING`: Global atomic counter for completion tracking
- **Depends on**: `async-syscall`, `async-runtime`

**async-net** (`crates/net/lib.rs`)
- Futures: `AcceptFuture`, `ConnectFuture`, `RecvFuture`, `SendFuture`
- Polls syscalls, returns `Poll::Pending` on EAGAIN (-11), registers fd waker via `runtime::register_fd_waker()`
## Build System

### Workspace Configuration
- **Workspace**: 4 member crates under `crates/`, main binary at root
- **Target**: `x86_64-unknown-none` (standard tier 2, NO custom JSON needed)
- **Build-std**: `.cargo/config.toml` auto-enables for all builds
- **Rustflags**: `-C relocation-model=static -C code-model=large` (in config.toml)
- **Binary**: 15KB stripped, statically linked ELF, NOT PIE

### Build & Run
```bash
# Build (nightly required for build-std)
cargo +nightly build --release

# Run with custom worker count
./target/x86_64-unknown-none/release/async-nostd 8

# Default: 4 workers
./target/x86_64-unknown-none/release/async-nostd
```

### Profile Settings
```toml
[profile.release]
opt-level = "z"      # Size optimization
lto = true           # Link-time optimization
codegen-units = 1    # Single codegen for better optimization
## Hard Rules for AI Agents

### Unsafe Code Placement
1. **Main binary (`src/main.rs`)**: ZERO unsafe code allowed
2. **Subcrates**: Unsafe only where necessary, always expose safe public APIs
3. All inline `asm!` blocks go in `crates/syscall/lib.rs` (private `syscallN` helpers)
4. Waker/task polling unsafe code in `crates/runtime/lib.rs` (`poll_task()`, `create_waker_for_handle()`)
5. When adding syscalls: Use generic `syscall1-6` helpers, expose safe typed wrapper
### Common Patterns

**Adding a new syscall:**
```rust
// In crates/syscall/lib.rs
pub fn getpid() -> i32 {
    let ret = unsafe { syscall1(39, 0) };  // __NR_getpid = 39
    if ret < 0 { -1 } else { ret as i32 }
}
```

**Using subcrates in main:**
```rust
use async_syscall as sys;
use async_executor::Executor;
use async_net::{AcceptFuture, SockAddrIn, AF_INET, SOCK_STREAM};

fn main() {
    let sfd = sys::socket(AF_INET, SOCK_STREAM, 0);
    let cfd = AcceptFuture::new(sfd).await;  // Async accept
}
```

**Spawning async tasks:**
```rust
let executor = Executor::new();
let task = async move {
    sys::write(1, b"Hello\n");
};
executor.enqueue_task(Box::new(task))?;
executor.start_workers(4)?;
executor.wait_all();
``` crate::syscall::write;
write(b"Hello\n");  // Safe wrapper over syscall 1 (write)
## Critical Constraints

### Async Model
- **Poll::Pending IS supported**: Futures can return Pending and will be re-polled
- Waker system: Task handles stored in lock-free schedule queue, woken via `runtime::wake_handle()`
- IO readiness: `ppoll()` monitors registered fds, wakes tasks on POLLIN/POLLOUT events
- Futures in `async-net` crate use this pattern (see `AcceptFuture::poll()`)

### Thread Model
- `spawn_thread()` uses `clone` with flags: CLONE_VM|FS|FILES|SIGHAND|SIGCHLD (17)
- **NOT CLONE_THREAD**: No pthread TLS, workers are process-like with shared VM
- Each worker: 64KB mmap stack, runs until `TASKS_REMAINING == 0`, then `exit(0)`
- Workers alternate: poll scheduled tasks → `ppoll_and_schedule()` if idle

### Memory Model  
- Bump allocator: 16MB mmap heap, CAS-based concurrent allocation
- No deallocation: All allocations permanent until process exit
- Lock-free node freelist (256 cap) for task scheduler nodes
```
## Debugging Tips

**Segfault causes:**
- Stack misalignment in `_start()` (must be 16-byte aligned before call)
- Wrong `clone` stack pointer (must point to TOP of mmap'd stack)
- Missing `unsafe { }` wrapper around `asm!` in Edition 2024 (mandatory)

**Build issues:**
- "extern blocks must be unsafe" → wrap `extern "C"` with `unsafe extern "C"`
- `#[no_mangle]` error → use `#[unsafe(no_mangle)]` in Edition 2024
- Missing nightly → all builds require `cargo +nightly` for build-std

**Runtime hangs:**
- Task waiting forever → check if fd registered with `runtime::register_fd_waker()`
- Recv/Send stuck → ensure socket set non-blocking via `fcntl(fd, F_SETFL, O_NONBLOCK)`
## Adding Features

**New subcrate:**
```bash
mkdir -p crates/newcrate
cargo init --lib crates/newcrate --name async-newcrate --edition 2024
# Add to workspace members in root Cargo.toml
# Add dependencies to crates/newcrate/Cargo.toml
```

**New async future:**
```rust
// In crates/net/lib.rs (or new crate)
pub struct MyFuture { fd: i32, registered: bool }

impl core::future::Future for MyFuture {
    type Output = isize;
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let r = async_syscall::my_syscall(self.fd);
        if r >= 0 { return Poll::Ready(r); }
        if r == -11 {  // EAGAIN
            if !self.registered {
                async_runtime::register_fd_waker(self.fd, 0x0001, cx.waker().clone());
                self.registered = true;
            }
            return Poll::Pending;
        }
        Poll::Ready(r)
    }
}
```

**Optimization tips:**
- Profile with `opt-level = "z"` for size, `"3"` for speed
- Check binary size: `ls -lh target/x86_64-unknown-none/release/async-nostd`
- Use `cargo bloat --release` to find large code sections (requires `cargo-bloat` install)         "syscall",
            in("rax") 39u64,  // __NR_getpid
            lateout("rax") ret,
            lateout("rcx") _,
            lateout("r11") _,
        );
    }
    ret as i32
}

pub fn getpid() -> i32 {
    unsafe { syscall_getpid() }
}
```

**New helper in runtime.rs:**
```rust
pub fn some_helper(x: usize) -> usize {
    unsafe {
        // Any unsafe operations needed
    }
}
```
